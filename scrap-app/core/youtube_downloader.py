import os
import youtube_dl
import tqdm 
from pydub import AudioSegment
from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api._errors import NoTranscriptFound
from collections import OrderedDict
from functools import partial
from glob import glob
import pandas as pd
import json

import ffmpeg

def makedirs(path):
    if not os.path.exists(path):
        print(" [*] Make directories : {}".format(path))
        os.makedirs(path)

def webm_to_wav(webm_filename, out_filename):
    webm_stream = ffmpeg.input(webm_filename, f='webm')
    wav_stream = ffmpeg.output(webm_stream, out_filename, format='wav', osr=16000, ac=1)
    ffmpeg.run(wav_stream)

class YoutubeDownloader:
    def __init__(self) -> None:
        self.output_dir = './'
        self.lang = 'ko'
        self.download_path = os.path.join(self.output_dir, "wavs/" + '%(id)s.%(ext)s')
        
    def download_audios(self, urls) -> None:
        options = {
            'format': 'bestaudio',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'wav',
                'preferredquality': '192'
            }],
            'postprocessor_args': [
                '-osr', '16000',
                '-ac', '1'
            ],
            'prefer_ffmpeg': True,
            'keepvideo': False,
            'outtmpl': self.download_path,  
            'ignoreerrors': True,
            'cachedir': ".cache2"
        }

        try:
            with youtube_dl.YoutubeDL(options) as ydl:
                ydl.download(urls)
        except Exception as e:
            print('error', e)

    def download_playlist(self, url) -> None:
        ydl = youtube_dl.YoutubeDL({'dump_single_json': 'True',
                            'extract_flat' : 'True'})
        result = ydl.extract_info(url, False)
        urls = ["https://www.youtube.com/watch?v="+row['id']  for row in result['entries']]
        # youtube_dl options
        download_audios(urls)
        
    def download_captions(self, skip_autogenerated=False) -> None:
        lang = self.lang
        video_id = []
        text = []
        start = []
        duration = []
        names = []
        full_names = []
        wav_dir = os.path.join(self.output_dir, "wavs")
        file_list = os.listdir(wav_dir)
        file_list_wav = [file for file in file_list if file.endswith(".wav")]
        for f in tqdm.tqdm(file_list_wav):
            try:
                video = f.split(".wav")[0]

                if skip_autogenerated:
                    try:
                        transcript_list = YouTubeTranscriptApi.list_transcripts(video)
                        subtitle = transcript_list.find_manually_created_transcript([lang])
                        subtitle = subtitle.fetch()
                    except NoTranscriptFound:
                        msg = "Skipping video {} because it has no manually generated subtitles"
                        print(msg.format(video))
                        continue
                else:
                    subtitle = YouTubeTranscriptApi.get_transcript(video, languages=[lang])

                for s in range(len(subtitle) - 1):
                    video_id.append(video)
                    full_name = os.path.join(wav_dir, video + '.' + str(s).zfill(4) + '.wav')
                    full_names.append(full_name)
                    name = video + '.' + str(s).zfill(4) + '.wav'
                    names.append(name)
                    subtitle[s]['text'] = ''.join(
                        [c for c in subtitle[s]['text'] if c not in ('!', '?', ',', '.', '\n', '~', '"', "'")])
                    text.append(subtitle[s]['text'])
                    start.append(subtitle[s]['start'])
                    if subtitle[s]['duration'] >= (subtitle[s + 1]['start'] - subtitle[s]['start']):
                        duration.append(subtitle[s + 1]['start'] - subtitle[s]['start'])
                    else:
                        duration.append(subtitle[s]['duration'])

            except Exception as e:
                print("error:", e)

        df = pd.DataFrame({"id": video_id, "text": text, "start": start, "duration": duration, "name": full_names})
        text_dir = os.path.join(self.output_dir, "text")
        makedirs(text_dir)

        df.to_csv(text_dir + '/subtitle.csv', encoding='utf-8')
        res = [i + '|' + j for i, j in zip(names, text)]
        df2 = pd.DataFrame({"name": res})
        df2.to_csv(os.path.join(self.output_dir, 'metadata.csv'), encoding='utf-8', header=False, index=False)
        file_data = OrderedDict()
        for i in range(df.shape[0]):
            file_data[df['name'][i]] = df['text'][i]
        with open(os.path.join(self.output_dir, 'alignment.json'), 'w', encoding="utf-8") as make_file:
            json.dump(file_data, make_file, ensure_ascii=False, indent="\n")

        print(os.path.basename(self.output_dir) + ' channel was finished')

    def audio_split(self, parallel=False) -> None:
        base_dir = self.output_dir + '/wavs/*.wav'
        audio_paths = glob(base_dir)
        audio_paths.sort()
        fn = partial(split_with_caption)
        parallel_run(fn, audio_paths, desc="Split with caption", parallel=parallel)
